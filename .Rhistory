geom_bar(stat = "identity"))
ggplotly(ggplot(data, aes(x = date, y = returnW)) +
#geom_bar(stat = "identity"))
geom_line())
ggplotly(ggplot(data, aes(x = date, y = returnW)) +
#geom_bar(stat = "identity"))
geom_line()+
#scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip())
ggplotly(ggplot(data, aes(x = date, y = returnW)) +
#geom_bar(stat = "identity"))
geom_line())
# Graph showing return per period
ggplotly(ggplot(data, aes(x = date, y = returnW)) +
stat_summary(fun.y = sum, geom = "bar", aes(fill = ..y.. > 0), position = "stack")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
# get date labels for each date.
# Graph showing return per coin, including mention of period
ggplot(data, aes(x = date, y = returnW)) +
geom_bar(stat = "identity"))
ggplot(data, aes(x = date, y = returnW)) +
geom_bar(stat = "identity")
ggplot(data, aes(x = date, y = returnW)) +
geom_bar(stat = "identity")+
#geom_line())
#scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip()
ggplot(data, aes(x = date, y = returnW)) +
geom_bar(stat = "identity")+
#geom_line())
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip()
ggplot(data, aes(x = date, y = returnW)) +
geom_bar(stat = "identity")+
#geom_line())
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip()
ggplot(data[data$returnW > 0, ], aes(x = date, y = returnW)) +
geom_bar(stat = "identity")+
#geom_line())
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip()
ggplotly(ggplot(data[data$returnW > 0, ], aes(x = date, y = returnW)) +
geom_bar(stat = "identity")+
#geom_line())
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip())
ggplotly(ggplot(data %>% filter(returnW > 0), aes(x = date, y = returnW)) +
geom_bar(stat = "identity")+
#geom_line())
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip())
ggplotly(ggplot(data %>% filter(returnW > 0), aes(x = date, y = returnW)) +
geom_bar(stat = "identity"))
View(data %>% filter(returnW > 0))
data %>% filter(returnW > 0) %>% View()
View(data)
p <- ggplot(data, aes(x = date, y = returnW))+
geom_bar(stat = "identity")
p <- ggplotly(p)
plot(p)
p <- ggplot(data, aes(x = date, y = returnW))+
geom_bar(stat = "identity")
p <- ggplotly(p)
plot(p)
p <- ggplot(data, aes(x = as.character(date), y = returnW))+
geom_bar(stat = "identity")
p <- ggplotly(p)
plot(p)
p <- ggplot(data, aes(x = as.character(date), y = returnW))+
geom_bar(stat = "identity")
p <- ggplotly(p)
p <- ggplot(data, aes(x = as.character(date), y = returnW))+
geom_bar(stat = "identity")
p2 <- ggplotly(p)
p <- ggplot(data)+
geom_bar(data,aes(x = as.character(date), y = returnW, stat = "identity"))
p <- ggplot(data)+
geom_bar(data,aes(x = as.character(date), y = returnW), stat = "identity"))
p <- ggplot(data)+
geom_bar(data,aes(x = as.character(date), y = returnW), stat = "identity")
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")
p2 <- ggplotly(p)
plot(p)
plot(p2)
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")
p2 <- ggplotly(p)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = date, y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = date, y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = as.Date(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = date, y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = returnW, y = as.character(date)), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = returnW, y = as.character(date)), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
ggplotly(p)
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE) %>%
ggplotly()
p <- ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE) %>%
ggplotly()
p <- ggplotly(
ggplot(data)+
geom_bar(aes(x = as.character(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
p$data[[1]]$orientation <- "h"
p$data[[2]]$orientation <- "h"
ggplotly(p)
p$data[[1]]$orientation <- "v"
p$data[[2]]$orientation <- "h"
ggplotly(p)
ggplotly(p)
l <- plotly_build(p)
p <- ggplotly(
ggplot(data)+
geom_bar(aes(x = date, y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
ggplotly(p)
p <- ggplotly(
ggplot(data)+
geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
ggplotly(p)
p <- ggplotly(
ggplot(data)+
geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
ggplotly(p)
# start and end date of analysis
SDate <- as.Date("2017-10-01")
EDate <- as.Date("2017-12-31")
# max rank of coins to be selected
MaxRank <- 150
# period between switches
HPeriod <- 3 # in days
SwitchDates <- seq(SDate, EDate, by = paste0(HPeriod, " days"))
# number of coins to be selected per period
CoinsPeriod <- 2
# percentage drop to sell
StopLoss <- 0.25 * 100  # stoploss percentage
# initial investment, total so its split per coin
Initial <- 500 # in dollars
# reinvest or not
Reinvest <- FALSE # boolean
# proceeds in BTC or cash
HoldInBTC <- FALSE # boolean
# (optional inputs)
# duration below sellpoint
# min % gain last week
# Calculate % gain over previous period and actual gain over next period. Not adjusted for stoploss.
df_modeldata <- df_marketdata %>%
filter(date >= SDate - HPeriod & date <= EDate + HPeriod,
rankthen <= MaxRank) %>%
arrange(ranknow, date) %>%
group_by(ranknow) %>%
mutate(prevClose = lag(Close, n = HPeriod, default = NA))   %>%
mutate(prevChg   = (Close - prevClose) / prevClose * 100) %>%
mutate(nextClose = lead(Close, n = HPeriod, default = NA))  %>%
mutate(nextChg   = (nextClose - Close) / Close * 100)      %>%
arrange(ranknow, desc(date))
# Find lowest point during next period
df_modeldata %<>%
arrange(ranknow, date) %>%
group_by(ranknow) %>%
mutate(periodlow = Inf)
# Dynamic loop to grab lowest point
for (i in 1:HPeriod) {
df_modeldata %<>%
mutate(leadlow = dplyr::lead(low, n = i, default = NA),
periodlow = ifelse(leadlow <= periodlow, leadlow, periodlow))
}
# Arrange dataframe again, remove unnecessary column, calculate lowest point in %,
# compare to stoploss and adjust.
df_modeldata %<>%
arrange(ranknow, desc(date)) %>%
select(-leadlow) %>%
mutate(nextLow = (periodlow - Close)/Close * 100) %>%
mutate(return = ifelse(nextLow <= -StopLoss * 100,  -StopLoss * 100, nextChg))   # applying stoploss
# Slice off begin and end of dataframe
df_modeldata %<>%
filter(date >= SDate & date <= EDate)
## Selector module}
# Let a model select x coins per period based on the criteria and put those rows
# in a dataframe for result analysis
df_selected = list()
df_modeldata %<>%
arrange(desc(prevChg)) %>%
filter(!is.na(nextClose))
SwitchDates <- seq(SDate, EDate, by = paste0(HPeriod, " days"))
for (i in SwitchDates){
df_selected[[i]] <- df_modeldata %>%
filter(date == i) %>%
ungroup() %>%
slice(1:CoinsPeriod)
}
df_selected <- bind_rows(df_selected)
df_selected$returnfiat <- df_selected$return / 100 * Initial / CoinsPeriod
View(df_selected)
renderText({
df_selected %>%
select(returnfiat) %>%
sum() %>%
print()
})
df_selected %>%
select(returnfiat) %>%
sum() %>%
print()
library(tidyr)      # data wrangling
library(dplyr)      # data wrangling
library(lubridate)  # dates
library(magrittr)   # pipelines
library(knitr)      # kable
library(ggplot2)    # plotting
library(plotly)     # dynamic plots
# Data Preparation
# We base our analyse on a dataset obtained from Coinmarketcap.com through the 'crypto' package.
# https://cran.r-project.org/web/packages/crypto/index.html
# Production dataset
df_marketdata      <- read.csv(file = "Data/Crypto-Markets.csv", stringsAsFactors = FALSE, sep = ";")
df_marketdata$date %<>% as.Date("%d-%m-%Y")
df_marketdata$low  %<>% as.numeric()
# Test dataset
#df_marketdata      <- read.csv(file = "Data/df_test.csv", stringsAsFactors = FALSE, sep = ";")
#df_marketdata$date %<>% as.Date("%Y-%m-%d")
#df_marketdata$low  %<>% as.numeric()
# Cleaning dataset. Check whether there are any NA's or strange values in the data that we obtained from CMC.
marketdata_NA <- df_marketdata %>%
select_if(function(x) any(is.na(x))) %>%
colnames()
# one Close value of coin EMV is 0, changing this to the low value of that date.
df_marketdata[df_marketdata$Close == 0, "Close"] <- 0.00000000000001
# Check for duplicate rows in the data
# Some coins have duplicate rows, for now we exclude these completely.
duplicates <- df_marketdata %>%
group_by(name, date) %>%
summarise(count = n()) %>%
filter(count != 1)
df_marketdata %<>%
filter(!name %in% duplicates$name)
# Calculate % gains per day.
df_marketdata %<>%
arrange(ranknow, date) %>%
group_by(ranknow) %>%
mutate(prevclose = dplyr::lag(Close, n = 1, default = NA)) %>%
mutate(percchg = (Close - prevclose) / prevclose * 100) %>%
arrange(ranknow, desc(date))
# Calculate rank for each day in the past.
df_marketdata %<>%
group_by(date) %>%
mutate(rankthen = dense_rank(desc(market)))
run_model <- function(SDate, EDate, MaxRank, HPeriod, CoinsPeriod, StopLoss, Initial, Reinvest, HoldInBTC){
# Calculate % gain over previous period and actual gain over next period. Not adjusted for stoploss.
df_modeldata <- df_marketdata %>%
filter(date >= SDate - HPeriod & date <= EDate + HPeriod,
rankthen <= MaxRank) %>%
arrange(ranknow, date) %>%
group_by(ranknow) %>%
mutate(prevClose = lag(Close, n = HPeriod, default = NA))   %>%
mutate(prevChg   = (Close - prevClose) / prevClose * 100) %>%
mutate(nextClose = lead(Close, n = HPeriod, default = NA))  %>%
mutate(nextChg   = (nextClose - Close) / Close * 100)      %>%
arrange(ranknow, desc(date))
# Find lowest point during next period
df_modeldata %<>%
arrange(ranknow, date) %>%
group_by(ranknow) %>%
mutate(periodlow = Inf)
# Dynamic loop to grab lowest point
for (i in 1:HPeriod) {
df_modeldata %<>%
mutate(leadlow = dplyr::lead(low, n = i, default = NA),
periodlow = ifelse(leadlow <= periodlow, leadlow, periodlow))
}
# Arrange dataframe again, remove unnecessary column, calculate lowest point in %,
# compare to stoploss and adjust.
df_modeldata %<>%
arrange(ranknow, desc(date)) %>%
select(-leadlow) %>%
mutate(nextLow = (periodlow - Close)/Close * 100) %>%
mutate(return = ifelse(nextLow <= -StopLoss * 100,  -StopLoss * 100, nextChg))   # applying stoploss
# Slice off begin and end of dataframe
df_modeldata %<>%
filter(date >= SDate & date <= EDate)
## Selector module}
# Let a model select x coins per period based on the criteria and put those rows
# in a dataframe for result analysis
df_selected = list()
df_modeldata %<>%
arrange(desc(prevChg)) %>%
filter(!is.na(nextClose))
SwitchDates <- seq(SDate, EDate, by = paste0(HPeriod, " days"))
for (i in SwitchDates){
df_selected[[i]] <- df_modeldata %>%
filter(date == i) %>%
ungroup() %>%
slice(1:CoinsPeriod)
}
df_selected <- bind_rows(df_selected)
df_selected$returnfiat <- df_selected$return / 100 * Initial / CoinsPeriod
return(df_selected)
}
df_selected %>%
select(returnfiat) %>%
sum() %>%
print()
renderText({
df_selected %>%
select(returnfiat) %>%
sum() %>%
print()
})
df_selected = list()
df_modeldata %<>%
arrange(desc(prevChg)) %>%
filter(!is.na(nextClose))
SwitchDates <- seq(SDate, EDate, by = paste0(HPeriod, " days"))
for (i in SwitchDates){
df_selected[[i]] <- df_modeldata %>%
filter(date == i) %>%
ungroup() %>%
slice(1:CoinsPeriod)
}
df_selected <- bind_rows(df_selected)
df_selected$returnfiat <- df_selected$return / 100 * Initial / CoinsPeriod
# Arrange dataframe again, remove unnecessary column, calculate lowest point in %,
# compare to stoploss and adjust.
df_modeldata %<>%
arrange(ranknow, desc(date)) %>%
select(-leadlow) %>%
mutate(nextLow = (periodlow - Close)/Close * 100) %>%
mutate(return = ifelse(nextLow <= -StopLoss * 100,  -StopLoss * 100, nextChg))   # applying stoploss
# Graph showing return per period
ggplotly(ggplot(data, aes(x = date, y = returnW)) +
stat_summary(fun.y = sum, geom = "bar", aes(fill = ..y.. > 0), position = "stack")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE))
# Graph showing return per period
ggplotly(ggplot(data, aes(x = date, y = returnW)) +
stat_summary(fun.y = sum, geom = "bar", aes(fill = ..y.. > 0), position = "stack")+
scale_fill_manual(values = c('red', 'darkgreen')) +
coord_flip() +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE))
p <- ggplotly(
ggplot(data)+
geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#coord_flip() +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
ggplotly(p)
p <- ggplotly(
ggplot(data)+
geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
ggplotly(p)
p <- ggplotly(
ggplot(data)+
stat_summary(fun.y = sum, geom = "bar", aes(x = as.POSIXct(date), fill = ..y.. > 0), position = "stack")+
#geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
p <- ggplotly(
ggplot(data)+
stat_summary(fun.y = sum, geom = "bar", aes(x = as.POSIXct(date), fill = ..y.. > 0), position = "stack")+
#geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
p <- ggplotly(
ggplot(data)+
stat_summary(fun.y = sum, geom = "bar", aes(x = as.POSIXct(date), y = returnW, fill = ..y.. > 0), position = "stack")+
#geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(fill = FALSE)
)
ggplotly(p)
p <- ggplotly(
ggplot(data)+
stat_summary(fun.y = sum, geom = "bar", aes(x = as.POSIXct(date), y = returnW, fill = ..y.. > 0), position = "stack")+
#geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(colour = FALSE, fill = FALSE)
)
ggplotly(p)
p <- ggplotly(
ggplot(data)+
stat_summary(fun.y = sum, geom = "bar", aes(x = as.POSIXct(date), y = returnW, fill = ..y.. > 0), position = "stack")+
#geom_bar(aes(x = as.POSIXct(date), y = returnW), stat = "identity")+
scale_fill_manual(values = c('red', 'darkgreen')) +
#scale_x_date(date_labels = "%b %d", date_breaks = paste0(HPeriod, " days"))+
guides(colour = FALSE, fill = FALSE)
)
p
